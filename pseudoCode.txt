/*
* Solver side code: Probably C with iso-c bindings as needed
*/

icf_result_t reqFineGrainSim(ARGS, int mpiRank)
{
	//Static variables are dirty but this is an okay use
	static int reqNumber = 0;

	///COMMENT: Should probably just use redis or something that can better support parallelism
	/// Assuming that for now we don't mind ranks being serialized. If we can provide asynchrony in lookups
	///   then we can better aggregate them and detect redundant calls before we hammer the file system

	//Open file for writing in format fgsReq_RANK_reqNumber
	//Write tab delimited string of arguments
	//Close file

	bool haveResult = false;
	while(!haveResult)
	{
		//Check if fgsAck_RANK_reqNumber exists
		//Open if it does
		//Read results
		if(results good)
		{
			haveResult = true;
			icf_result_t retVal = STUFF;
		}
		//Close file
	}

	return retVal;
}


/*
* ALer code: Python until otherwise
*/

// Read config file to determine what ranks this ALer is responsible for
// Make array of ints to keep track of req count for each rank
for each rank:
	check if we have a new req
	process req as either LAMMPs or Mystic
	write result to file




INTERFACE
	LAMMPS: x
		Temperature, densities
			objective.py
				Find this in one of our respos
					grep "demo_update1/in.MARBLE"
	
	